---
title: "spotify"
format: html
---
# Library
```{r}
library(tidyverse)
library(dplyr)
library(ggplot2)
library(shiny)
```

# Spotify data
```{r}
set.seed(123)

load("~/Dropbox (University of Michigan)/UMICH/Years/(4) Senior Year/courses/DATA 306/lectures/data/spotify_mpd_001.RData")
# load("spotify_mpd_001.RData")

```

# track_attr
- The `track_attr` table contains information about the audio features of each track.
- These are computed by Spotify using signal processing and machine learning.
```{r}
track_attr
colnames(track_attr)
```
# filter cols, NA 
```{r}
num_vars <- c("danceability", "energy", "loudness", 
              "acousticness", "valence", "tempo")

new_track_attr <- track_attr |> 
  select(track_id, artists, track_name, all_of(num_vars), track_genre) |>
  drop_na() |>
  mutate(across(all_of(num_vars), as.numeric))

#new_track_attr
```

#Select 3 songs
```{r}
# user_input <- new_track_attr |>
#   filter(track_id %in% c(1004300, 644949, 2188242))

# random
user_input <- new_track_attr |> ungroup() |> sample_n(3)

user_input
```

# logistic model
```{r}
train_data <- new_track_attr |>
  mutate(liked = ifelse(track_id %in% user_input$track_id, 1L, 0L)) |>
  mutate(is_genre = ifelse(track_genre %in% user_input$track_genre, 1L, 0L))


train_data
```
# sample negatives (not liked) so model doesn't "choke": can function smoothly
```{r}
negatives <- train_data |> filter(liked == 0) |> sample_n(min(300, n()))
positives <- train_data |> filter(liked == 1)
train_sub <- bind_rows(positives, negatives)
```

# generating model
```{r}
# preference_model <- lm(liked ~ danceability + energy + loudness + acousticness + valence + tempo,
#                        data = train_data)

preference_model <- glm(liked ~ danceability + energy + loudness + acousticness + valence + tempo + is_genre,
                       data = train_sub, family = binomial)

preference_model |> summary()
```

# generating prediction results
```{r}
prediction_result <- train_data |>
  ungroup() |>
  mutate(predicted_score = predict(preference_model, newdata = train_data, type = "response")) |>
  filter(!track_id %in% user_input$track_id) |> # remove input songs
  arrange(desc(predicted_score)) # order

prediction_result

best_song <- prediction_result[1, ]

print(paste("Recommnedation:", best_song$track_name, "-", best_song$artists))
print(paste("Predicted score:", round(best_song$predicted_score, 5)))
```
# generates a target profile for songs, creating weights for euclidean distanes
```{r}
target_profile <- user_input |>
  summarise(across(all_of(num_vars), mean, .names = "target_{.col}"))

#target_profile
coefs <- coef(preference_model)
feature_weights <- abs(coefs[ names(coefs) %in% num_vars ])
feature_weights <- feature_weights[num_vars]
```

```{r}
target_vals <- as.numeric(target_profile[1, paste0("target_", num_vars)])

# Euclidean Distance: sqrt((x1-x2)^2 + (y1-y2)^2 ...)
recommendations <- new_track_attr |> 
  filter(!track_id %in% user_input$track_id) |>
  rowwise() |> mutate(
    euclid_distance = sum( #unweighted squared Euclidean distance on standardized features
      (c_across(all_of(num_vars)) - target_vals)^2
    ),
    weighted_distance = sum( #weighted distance using model-derived feature importance
      feature_weights * (c_across(all_of(num_vars)) - target_vals)
    )
  ) |>
  ungroup() |>
  # adding predicted "like" probability from the logistic model
  mutate(
    like_score = predict(
      preference_model, 
      newdata = cur_data_all() |> 
        mutate(
      is_genre = ifelse(track_genre %in% user_input$track_genre, 1L, 0L) #must recompute genre match
    ),
    type = "response"
  )
)
```
```{r}

# get predicted "like" score by model
top_by_model <- recommendations |> arrange(desc(like_score)) |> select(track_name, artists, like_score, euclid_distance, weighted_distance) |> head(10)
top_by_similarity <- recommendations |> mutate(dist_from_zero = abs(weighted_distance)) |> arrange(
  dist_from_zero #generate values closest to zero
  ) |>
  select(track_name, artists, like_score, weighted_distance) |>
  head(10)

top_by_model
top_by_similarity
```



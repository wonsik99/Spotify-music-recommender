---
title: "spotify"
format: html
---
# Library
```{r}
library(tidyverse)
library(dplyr)
library(ggplot2)
library(shiny)
```

# Spotify data
```{r}
# There are 1 million playlist in the main dataset
# spotify_mpd_01.RData: 0.1% of the main dataset
# spotify_mpd_001.RData: 0.001% of the main dataset
# We will start with 001 for now

load("spotify_mpd_01.RData")
# load("spotify_mpd_001.RData")

```

# track_attr
- The `track_attr` table contains information about the audio features of each track.
- These are computed by Spotify using signal processing and machine learning.
```{r}
track_attr
colnames(track_attr)
```
# filter cols, NA 
```{r}
new_track_attr <- track_attr |> 
  select(track_id, artists, track_name, danceability, energy, loudness,
         acousticness, valence, tempo, track_genre) |>
  drop_na()

new_track_attr
```

#Select 3 songs
```{r}
# #acoustic
# user_input <- new_track_attr |>
#   filter(track_id %in% c(1004300, 644949, 2188242)) |> ungroup()

# 1 acoustic, 2 rock
user_input <- new_track_attr |>
  filter(track_id %in% c(644949, 1489302, 717255)) |> ungroup()


# random
# user_input <- new_track_attr |> ungroup() |> sample_n(3)

user_input
```

# lm model
```{r}
train_data <- new_track_attr |>
  mutate(liked = ifelse(track_id %in% user_input$track_id, 1, 0)) |>
  mutate(is_genre = ifelse(track_genre %in% user_input$track_genre, 1, 0))


train_data

# preference_model <- lm(liked ~ danceability + energy + loudness + acousticness + valence + tempo,
#                        data = train_data)

preference_model <- glm(liked ~ danceability + energy + loudness + acousticness + valence + tempo + is_genre,
                       data = train_data, family = binomial)

preference_model |> summary()


```


```{r}
prediction_result <- train_data |>
  ungroup() |>
  mutate(predicted_score = predict(preference_model, newdata = train_data, type = "response")) |>
  filter(!track_id %in% user_input$track_id) |> # remove input songs
  arrange(desc(predicted_score)) # order

prediction_result

best_song <- prediction_result[1, ]

print(paste("Recommnedation:", best_song$track_name, "-", best_song$artists))
print(paste("Predicted score:", round(best_song$predicted_score, 5)))
```

```{r}
target_profile <- user_input |>
  summarise(
    target_dance = mean(danceability),
    target_energy = mean(energy),
    target_loudness = mean(loudness),
    target_acoustic = mean(acousticness),
    target_valence = mean(valence),
    target_tempo = mean(tempo)
  )


# Euclidean Distance: sqrt((x1-x2)^2 + (y1-y2)^2 ...)
recommendations <- new_track_attr |>
  ungroup() |>
  filter(!track_id %in% user_input$track_id) |> 
  mutate(
    
    similarity_distance = sqrt(
      (danceability - target_profile$target_dance)^2 +
      (energy       - target_profile$target_energy)^2 +
      (loudness     - target_profile$target_loudness)^2 +
      (acousticness - target_profile$target_acoustic)^2 +
      (valence      - target_profile$target_valence)^2 +
      (tempo        - target_profile$target_tempo)^2 
      
    )
  ) |>

  arrange(similarity_distance)


head(recommendations, 10)
```


#cosine simialrity(final model)
```{r}

# scaling
normalize <- function(x) {
  return ((x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE)))
  # return ((x - min(x)) / (max(x) - min(x)))
}

# scale 0 to 1
scaled_tracks <- new_track_attr |>
  ungroup() |>
  mutate(across(c(danceability, energy, loudness, acousticness, valence, tempo), normalize))

# scaled_tracks


# target vector
target_vector <- scaled_tracks |>
  filter(track_id %in% user_input$track_id) |>
  select(danceability, energy, loudness, acousticness, valence, tempo) |>
  colMeans(na.rm = TRUE) #summarise(mean)

# matrix
track_matrix <- scaled_tracks |>
  select(danceability, energy, loudness, acousticness, valence, tempo) |>
  as.matrix()

# dot product
dot_product <- track_matrix %*% target_vector

# norm
norm_tracks <- sqrt(rowSums(track_matrix^2))
norm_target <- sqrt(sum(target_vector^2))

# calculate cosine similarity
cosine_scores <- as.vector(dot_product / (norm_tracks * norm_target))

# result
recommendations <- new_track_attr |>
  ungroup() |>
  mutate(
    similarity_score = cosine_scores, 
    
    # genre(?)
    genre_match = track_genre %in% user_input$track_genre,
    adjusted_similarity = ifelse(genre_match, 
                                 similarity_score + 0.01, 
                                 similarity_score)
  ) |>
  filter(!track_id %in% user_input$track_id) |> # remove user input
  arrange(desc(similarity_score)) |>         
  # group_by(artists) |> slice_head(n = 2) |>
  head(10)

print(recommendations)
```

#weight for testing
```{r}
# library(tidyverse)
# 
# scaled_data <- new_track_attr 
# 
# user_features <- scaled_data |>
#   filter(track_id %in% user_input$track_id) |>
#   select(danceability, energy, loudness, acousticness, valence, tempo)
# 
# user_features
# 
# feature_matrix <- as.matrix(user_features)
# dist_matrix <- as.matrix(dist(feature_matrix))
# 
# # how far each songs are
# total_distance_per_song <- rowSums(dist_matrix)
# 
# # weight calculate
# song_weights <- 1 / (total_distance_per_song^2 + 0.001)
# song_weights <- song_weights / sum(song_weights) 
# 
# # weight result
# print(data.frame(Track=user_input$track_name, Weight=round(song_weights, 4)))
# 

```
